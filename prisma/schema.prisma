generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

/// Message model for storing Slack messages
model Message {
  /// Unique identifier for the message
  id                        String                      @id @default(cuid())
  /// Slack message ID (unique)
  slackId                   String                      @unique @map("slack_id")
  /// Message text content
  text                      String
  /// Slack user ID who sent the message
  userId                    String                      @map("user_id")
  /// Username of the sender
  username                  String
  /// Channel where message was sent
  channel                   String
  /// Slack timestamp (converted to DateTime)
  timestamp                 DateTime
  /// Thread timestamp - same as timestamp for parent messages, different for replies
  threadTs                  String?                     @map("thread_ts")
  /// Whether this is a thread reply (has threadTs different from slackId)
  isThreadReply             Boolean                     @default(false) @map("is_thread_reply")
  /// Parent message (self-referential for thread support)
  parentMessageId           String?                     @map("parent_message_id")
  /// Record creation timestamp
  createdAt                 DateTime                    @default(now()) @map("created_at")
  /// Record update timestamp
  updatedAt                 DateTime                    @updatedAt @map("updated_at")
  MessageToMessageSelection MessageToMessageSelection[]
  documentMessages          DocumentMessage[]
  messageFAQs               MessageFAQ[]
  parentMessage             Message?                    @relation("ThreadReplies", fields: [parentMessageId], references: [id])
  threadReplies             Message[]                   @relation("ThreadReplies")
  piiDetections             PIIDetection[]

  @@index([channel])
  @@index([timestamp])
  @@index([userId])
  @@index([threadTs])
  @@index([isThreadReply])
  @@index([parentMessageId])
  @@map("messages")
}

/// Processed documents created from Slack messages
model ProcessedDocument {
  /// Unique identifier for the document
  id                   String            @id @default(cuid())
  /// Document title
  title                String
  /// Document description/summary
  description          String
  /// Document category for organization
  category             String
  /// Document processing status
  status               DocumentStatus    @default(DRAFT)
  /// AI confidence score for document quality (0-1)
  confidenceScore      Float             @default(0) @map("confidence_score")
  /// User who created the document (if manual)
  createdBy            String?           @map("created_by")
  /// Record creation timestamp
  createdAt            DateTime          @default(now()) @map("created_at")
  /// Record update timestamp
  updatedAt            DateTime          @updatedAt @map("updated_at")
  /// AI-powered conversation analysis results
  conversationAnalysis Json?             @map("conversation_analysis")
  /// Related automation job that created this document
  automationJobId      String?           @map("automation_job_id")
  documentFAQs         DocumentFAQ[]
  documentMessages     DocumentMessage[]
  automationJob        AutomationJob?    @relation(fields: [automationJobId], references: [id])

  @@index([status])
  @@index([category])
  @@index([createdAt])
  @@map("processed_documents")
}

/// FAQ entries generated from processed documents
model FAQ {
  /// Unique identifier for the FAQ
  id              String        @id @default(cuid())
  /// FAQ question text
  question        String
  /// FAQ answer text
  answer          String
  /// FAQ category for organization
  category        String
  /// FAQ approval status
  status          FAQStatus     @default(PENDING)
  /// AI confidence score for FAQ quality (0-1)
  confidenceScore Float         @default(0) @map("confidence_score")
  /// User who approved the FAQ
  approvedBy      String?       @map("approved_by")
  /// Approval timestamp
  approvedAt      DateTime?     @map("approved_at")
  /// Record creation timestamp
  createdAt       DateTime      @default(now()) @map("created_at")
  /// Record update timestamp
  updatedAt       DateTime      @updatedAt @map("updated_at")
  documentFAQs    DocumentFAQ[]
  messageFAQs     MessageFAQ[]

  @@index([status])
  @@index([category])
  @@index([createdAt])
  @@index([approvedBy])
  @@map("faqs")
}

/// Automation rules for scheduled and event-driven processing
model AutomationRule {
  /// Unique identifier for the rule
  id          String          @id @default(cuid())
  /// Rule name
  name        String
  /// Rule description
  description String
  /// Whether the rule is enabled
  enabled     Boolean         @default(true)
  /// User who created the rule
  createdBy   String          @map("created_by")
  /// Simple execution tracking
  lastRun     DateTime?       @map("last_run")
  nextRun     DateTime?       @map("next_run")
  runCount    Int             @default(0) @map("run_count")
  /// Record timestamps
  createdAt   DateTime        @default(now()) @map("created_at")
  updatedAt   DateTime        @updatedAt @map("updated_at")
  /// When to run (cron expression for scheduled rules)
  schedule    String?
  /// What type of job to create
  jobType     JobType?        @default(DOCUMENT_CREATION)
  /// Configuration for the job (JSON)
  jobConfig   Json?           @default("{}") @map("job_config")
  jobs        AutomationJob[]

  @@index([enabled])
  @@index([nextRun])
  @@index([createdAt])
  @@map("automation_rules")
}

/// Jobs created by automation rules
model AutomationJob {
  /// Unique identifier for the job
  id                 String              @id(map: "automation_jobs_new_pkey") @default(cuid())
  /// Which automation rule created this job
  automationRuleId   String              @map("automation_rule_id")
  /// Job type (inherited from rule)
  jobType            JobType             @default(DOCUMENT_CREATION)
  /// Job status
  status             JobStatus           @default(QUEUED)
  /// Input data for the job (JSON)
  inputData          Json                @map("input_data")
  /// Output data from the job (JSON)
  outputData         Json?               @map("output_data")
  /// Error message if job failed
  errorMessage       String?             @map("error_message")
  /// Job progress (0-1)
  progress           Float               @default(0)
  /// Number of retry attempts
  retryCount         Int                 @default(0) @map("retry_count")
  /// Job timestamps
  startedAt          DateTime?           @map("started_at")
  completedAt        DateTime?           @map("completed_at")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @default(now()) @updatedAt @map("updated_at")
  automationRule     AutomationRule      @relation(fields: [automationRuleId], references: [id], onDelete: Cascade)
  processedDocuments ProcessedDocument[]

  @@index([automationRuleId])
  @@index([status])
  @@index([jobType])
  @@index([createdAt])
  @@map("automation_jobs")
}

/// System-wide processing settings and configuration
model ProcessingSettings {
  /// Settings identifier (usually 'default')
  id        String   @id
  /// Settings configuration (JSON)
  settings  Json
  /// Record creation timestamp
  createdAt DateTime @default(now()) @map("created_at")
  /// Record update timestamp
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("processing_settings")
}

/// PII detection and removal tracking
model PIIDetection {
  /// Unique identifier for the PII detection
  id              String        @id @default(cuid())
  /// Source type (MESSAGE, DOCUMENT)
  sourceType      PIISourceType @default(MESSAGE)
  /// Source entity ID
  sourceId        String        @map("source_id")
  /// Type of PII detected
  piiType         PIIType       @default(EMAIL)
  /// Original text before replacement
  originalText    String        @map("original_text")
  /// Replacement text used
  replacementText String        @map("replacement_text")
  /// AI confidence in PII detection (0-1)
  confidence      Float         @default(0)
  /// Review status
  status          PIIStatus     @default(AUTO_REPLACED)
  /// User who reviewed the PII detection
  reviewedBy      String?       @map("reviewed_by")
  /// Review timestamp
  reviewedAt      DateTime?     @map("reviewed_at")
  /// Record creation timestamp
  createdAt       DateTime      @default(now()) @map("created_at")
  message         Message       @relation(fields: [sourceId], references: [id])

  @@index([sourceType, sourceId])
  @@index([piiType])
  @@index([status])
  @@index([createdAt])
  @@map("pii_detections")
}

/// Junction table: Message to Document relationship with full traceability
model DocumentMessage {
  /// Unique identifier for the relationship
  id                   String            @id @default(cuid())
  /// Document ID
  documentId           String            @map("document_id")
  /// Message ID
  messageId            String            @map("message_id")
  /// How the message was included in the document
  inclusionMethod      InclusionMethod   @default(AI_AUTOMATIC)
  /// Role of the message in the document
  messageRole          MessageRole       @default(CONTEXT)
  /// User who added the message (if manual)
  addedBy              String?           @map("added_by")
  /// Timestamp when message was added
  addedAt              DateTime          @default(now()) @map("added_at")
  /// AI confidence in including this message (0-1)
  processingConfidence Float             @default(0) @map("processing_confidence")
  /// Reason if message was later removed
  removalReason        String?           @map("removal_reason")
  document             ProcessedDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  message              Message           @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([documentId, messageId])
  @@index([documentId])
  @@index([messageId])
  @@index([messageRole])
  @@index([inclusionMethod])
  @@map("document_messages")
}

/// Junction table: Document to FAQ relationship with generation tracking
model DocumentFAQ {
  /// Unique identifier for the relationship
  id               String            @id @default(cuid())
  /// Document ID
  documentId       String            @map("document_id")
  /// FAQ ID
  faqId            String            @map("faq_id")
  /// How the FAQ was generated
  generationMethod GenerationMethod  @default(AI_GENERATED)
  /// Specific message IDs that contributed to this FAQ
  sourceMessageIds String[]          @map("source_message_ids")
  /// AI confidence in FAQ generation (0-1)
  confidenceScore  Float             @default(0) @map("confidence_score")
  /// User who generated the FAQ (if manual)
  generatedBy      String?           @map("generated_by")
  /// Record creation timestamp
  createdAt        DateTime          @default(now()) @map("created_at")
  document         ProcessedDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  faq              FAQ               @relation(fields: [faqId], references: [id], onDelete: Cascade)

  @@unique([documentId, faqId])
  @@index([documentId])
  @@index([faqId])
  @@index([generationMethod])
  @@map("document_faqs")
}

/// Junction table: Direct Message to FAQ traceability
model MessageFAQ {
  /// Unique identifier for the relationship
  id               String           @id @default(cuid())
  /// Message ID
  messageId        String           @map("message_id")
  /// FAQ ID
  faqId            String           @map("faq_id")
  /// Type of contribution this message made to the FAQ
  contributionType ContributionType @default(SUPPORTING_CONTEXT)
  /// Document that facilitated this relationship
  documentId       String?          @map("document_id")
  /// Record creation timestamp
  createdAt        DateTime         @default(now()) @map("created_at")
  faq              FAQ              @relation(fields: [faqId], references: [id], onDelete: Cascade)
  message          Message          @relation(fields: [messageId], references: [id], onDelete: Cascade)

  @@unique([messageId, faqId])
  @@index([messageId])
  @@index([faqId])
  @@index([contributionType])
  @@index([documentId])
  @@map("message_faqs")
}

/// Manual message selections for curation
model MessageSelection {
  /// Unique identifier for the selection
  id                        String                      @id @default(cuid())
  /// User who made the selection
  userId                    String                      @map("user_id")
  /// Name/description of the selection
  selectionName             String                      @map("selection_name")
  /// Array of selected message IDs
  messageIds                String[]                    @map("message_ids")
  /// Purpose of the selection
  purpose                   SelectionPurpose            @default(DOCUMENT_CREATION)
  /// Record creation timestamp
  createdAt                 DateTime                    @default(now()) @map("created_at")
  MessageToMessageSelection MessageToMessageSelection[]

  @@index([userId])
  @@index([purpose])
  @@index([createdAt])
  @@map("message_selections")
}

/// User curation activity tracking
model CurationActivity {
  /// Unique identifier for the activity
  id           String       @id @default(cuid())
  /// User who performed the activity
  userId       String       @map("user_id")
  /// Type of curation activity
  activityType ActivityType @default(MESSAGE_ADDED)
  /// Target entity ID (document, selection, etc.)
  targetId     String       @map("target_id")
  /// Details about what changed (JSON)
  details      Json
  /// Activity timestamp
  timestamp    DateTime     @default(now())

  @@index([userId])
  @@index([activityType])
  @@index([timestamp])
  @@index([targetId])
  @@map("curation_activities")
}

/// Slack webhook event log for audit trail and error recovery
model SlackEvent {
  /// Unique identifier for the event
  id            String           @id @default(cuid())
  /// Slack event ID (for deduplication)
  slackEventId  String?          @map("slack_event_id")
  /// Event type (event_callback, url_verification)
  eventType     String           @map("event_type")
  /// Event subtype (message, message_changed, message_deleted)
  eventSubtype  String?          @map("event_subtype")
  /// Raw payload from Slack
  payload       Json
  /// Processing status
  status        SlackEventStatus @default(PENDING)
  /// Error message if processing failed
  errorMessage  String?          @map("error_message")
  /// Number of processing attempts
  attempts      Int              @default(0)
  /// Last attempt timestamp
  lastAttemptAt DateTime?        @map("last_attempt_at")
  /// Related message ID (if applicable)
  messageId     String?          @map("message_id")
  /// Channel where event occurred
  channel       String?
  /// Record creation timestamp
  createdAt     DateTime         @default(now()) @map("created_at")
  /// Record update timestamp
  updatedAt     DateTime         @updatedAt @map("updated_at")

  @@index([slackEventId])
  @@index([status])
  @@index([eventType])
  @@index([createdAt])
  @@index([channel])
  @@map("slack_events")
}

/// Channel model for future enhancements
model Channel {
  /// Unique identifier for the channel
  id          String   @id @default(cuid())
  /// Slack channel ID (unique)
  slackId     String   @unique @map("slack_id")
  /// Channel name
  name        String
  /// Channel description
  description String?
  /// Whether channel is private
  isPrivate   Boolean  @default(false) @map("is_private")
  /// Record creation timestamp
  createdAt   DateTime @default(now()) @map("created_at")
  /// Record update timestamp  
  updatedAt   DateTime @updatedAt @map("updated_at")

  @@map("channels")
}

model MessageToMessageSelection {
  A                  String
  B                  String
  messages           Message          @relation(fields: [A], references: [id], onDelete: Cascade)
  message_selections MessageSelection @relation(fields: [B], references: [id], onDelete: Cascade)

  @@unique([A, B], map: "_MessageToMessageSelection_AB_unique")
  @@index([B], map: "_MessageToMessageSelection_B_index")
  @@map("_MessageToMessageSelection")
}

/// Document processing status
enum DocumentStatus {
  DRAFT
  PROCESSING
  COMPLETE
  ERROR
}

/// FAQ approval status
enum FAQStatus {
  PENDING
  APPROVED
  REJECTED
  ARCHIVED
}

/// Background job status
enum JobStatus {
  QUEUED
  PROCESSING
  COMPLETE
  FAILED
  CANCELLED
  PAUSED
  DELETED
}

/// Background job types
enum JobType {
  DOCUMENT_CREATION
  DOCUMENT_ENHANCEMENT
  FAQ_GENERATION
}

/// PII source types
enum PIISourceType {
  MESSAGE
  DOCUMENT
}

/// PII detection types
enum PIIType {
  EMAIL
  PHONE
  NAME
  URL
  CUSTOM
}

/// PII detection status
enum PIIStatus {
  AUTO_REPLACED
  PENDING_REVIEW
  WHITELISTED
  FLAGGED
}

/// Message inclusion methods
enum InclusionMethod {
  AI_AUTOMATIC
  USER_MANUAL
  USER_ENHANCED
}

/// Message roles in documents
enum MessageRole {
  QUESTION
  ANSWER
  CONTEXT
  FOLLOW_UP
  CONFIRMATION
}

/// FAQ generation methods
enum GenerationMethod {
  AI_GENERATED
  USER_CREATED
  HYBRID
}

/// Message contribution types to FAQs
enum ContributionType {
  PRIMARY_QUESTION
  PRIMARY_ANSWER
  SUPPORTING_CONTEXT
}

/// Message selection purposes
enum SelectionPurpose {
  DOCUMENT_CREATION
  DOCUMENT_ENHANCEMENT
  RESEARCH
}

/// Curation activity types
enum ActivityType {
  MESSAGE_ADDED
  DOCUMENT_MERGED
  MESSAGES_SELECTED
}

/// Slack event processing status
enum SlackEventStatus {
  PENDING
  PROCESSING
  SUCCESS
  FAILED
  SKIPPED
}

/// Salesforce connection and authentication tracking
model SalesforceConnection {
  /// Unique identifier for the connection
  id                    String    @id @default(cuid())
  /// Session identifier for this connection
  sessionId             String    @unique @map("session_id")
  /// Salesforce organization ID
  organizationId        String    @map("organization_id")
  /// Salesforce user ID
  salesforceUserId      String    @map("salesforce_user_id")
  /// Salesforce username
  username              String
  /// User's display name from Salesforce
  displayName           String?   @map("display_name")
  /// Salesforce instance URL
  instanceUrl           String    @map("instance_url")
  /// Encrypted access token
  accessToken           String    @map("access_token")
  /// Encrypted refresh token
  refreshToken          String?   @map("refresh_token")
  /// Token type (usually 'Bearer')
  tokenType             String    @default("Bearer") @map("token_type")
  /// When the access token expires
  tokenExpiresAt        DateTime? @map("token_expires_at")
  /// Connection status
  status                SalesforceConnectionDBStatus @default(ACTIVE)
  /// Last successful API call timestamp
  lastActivityAt        DateTime? @map("last_activity_at")
  /// Number of API calls made with this connection
  apiCallCount          Int       @default(0) @map("api_call_count")
  /// Last known API usage limits
  dailyApiLimit         Int?      @map("daily_api_limit")
  /// Last known API usage count
  dailyApiUsed          Int?      @map("daily_api_used")
  /// Connection metadata (JSON)
  metadata              Json?
  /// Record creation timestamp
  createdAt             DateTime  @default(now()) @map("created_at")
  /// Record update timestamp
  updatedAt             DateTime  @updatedAt @map("updated_at")
  /// When connection was last used
  lastUsedAt            DateTime? @map("last_used_at")
  /// Connection disconnect timestamp
  disconnectedAt        DateTime? @map("disconnected_at")

  @@index([sessionId])
  @@index([organizationId])
  @@index([salesforceUserId])
  @@index([status])
  @@index([createdAt])
  @@map("salesforce_connections")
}

/// OAuth state storage for development persistence
model OAuthState {
  /// State parameter (unique identifier)
  state         String    @id
  /// User ID (optional)
  userId        String?   @map("user_id")
  /// Redirect destination after OAuth
  redirectTo    String?   @map("redirect_to")
  /// PKCE code verifier
  codeVerifier  String    @map("code_verifier")
  /// When this state expires
  expiresAt     DateTime  @map("expires_at")
  /// Record creation timestamp
  createdAt     DateTime  @default(now()) @map("created_at")

  @@index([expiresAt])
  @@map("oauth_states")
}

enum AutomationStatus {
  RUNNING
  COMPLETED
  PARTIAL
  FAILED
  CANCELLED
}

/// Salesforce connection status
enum SalesforceConnectionDBStatus {
  ACTIVE
  EXPIRED
  REVOKED
  ERROR
  DISCONNECTED
}
